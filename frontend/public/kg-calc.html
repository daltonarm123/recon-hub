<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>KG Battle Calculator (UI v2)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f1730;
      --panel2:#0c1328;
      --text:#e7ecff;
      --muted:#9aa6d6;
      --border:rgba(255,255,255,.10);
      --accent:#5aa0ff;
      --danger:#ff6b6b;
      --ok:#58d68d;
      --radius:14px;
      --pad:14px;
      --rowH:34px;
      --font:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    }
    *{ box-sizing:border-box }
    body{
      margin:0;
      font-family:var(--font);
      background:radial-gradient(1200px 600px at 20% 0%, #101b44 0%, var(--bg) 55%);
      color:var(--text);
    }
    .wrap{ max-width:1200px; margin:20px auto; padding:0 14px 28px; }
    .topbar{ display:flex; gap:12px; align-items:flex-start; justify-content:space-between; margin-bottom:12px; }
    .title{ display:flex; flex-direction:column; gap:2px; }
    .title h1{ margin:0; font-size:18px; letter-spacing:.2px; }
    .title .sub{ color:var(--muted); font-size:12px; }

    .pillrow{ display:flex; flex-wrap:wrap; gap:8px; align-items:center; justify-content:flex-end; }
    .pill{
      background:rgba(255,255,255,.06);
      border:1px solid var(--border);
      padding:6px 10px;
      border-radius:999px;
      font-size:12px;
      color:var(--muted);
      display:flex;
      gap:8px;
      align-items:center;
    }
    .pill input{ transform:translateY(1px); }

    .grid{ display:grid; grid-template-columns:1fr 1fr; gap:14px; }
    @media (max-width: 980px){ .grid{ grid-template-columns:1fr; } }

    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid var(--border);
      border-radius:var(--radius);
      overflow:hidden;
      box-shadow:0 10px 30px rgba(0,0,0,.25);
    }
    .cardHeader{
      padding:12px 14px;
      background:rgba(255,255,255,.03);
      border-bottom:1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .cardHeader .h{ display:flex; flex-direction:column; gap:2px; }
    .cardHeader .h .t{ font-weight:700; font-size:13px; }
    .cardHeader .h .d{ font-size:12px; color:var(--muted); }

    .cardBody{ padding:12px 14px; }
    .rows{ display:flex; flex-direction:column; gap:8px; }

    .row{
      display:grid;
      grid-template-columns:1.3fr 1fr;
      gap:10px;
      align-items:center;
      min-height:var(--rowH);
    }
    .row.compact{ min-height:var(--rowH); }
    .lbl{
      font-size:12px;
      color:var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .inp,.ta{
      width:100%;
      background:rgba(0,0,0,.25);
      border:1px solid var(--border);
      border-radius:10px;
      padding:8px 10px;
      color:var(--text);
      outline:none;
    }
    .inp{ height:var(--rowH); }
    .ta{
      min-height:120px;
      resize:vertical;
      font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
      font-size:12px;
      line-height:1.35;
    }

    .btnrow{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    .btn{
      background:rgba(90,160,255,.16);
      border:1px solid rgba(90,160,255,.35);
      color:var(--text);
      padding:8px 10px;
      border-radius:10px;
      cursor:pointer;
      font-size:12px;
    }
    .btn:hover{ border-color:rgba(90,160,255,.6); }
    .btn.ghost{
      background:rgba(255,255,255,.06);
      border:1px solid var(--border);
      color:var(--muted);
    }

    .status{
      margin-top:10px;
      font-size:12px;
      color:var(--muted);
      display:flex;
      gap:10px;
      flex-wrap:wrap;
    }
    .kv{
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--border);
      background:rgba(255,255,255,.04);
    }
    .kv b{ color:var(--text); font-weight:700; }

    .divider{ height:1px; background:var(--border); margin:12px 0; }
    .sectionTitle{
      margin:0 0 8px;
      font-size:12px;
      color:var(--muted);
      letter-spacing:.2px;
      text-transform:uppercase;
    }

    .twocol{ display:grid; grid-template-columns:1fr 1fr; gap:10px; }
    @media (max-width: 980px){ .twocol{ grid-template-columns:1fr; } }

    .troopList{ display:flex; flex-direction:column; gap:6px; margin-top:6px; }
    .troopItem{ display:grid; grid-template-columns:1.3fr 1fr; gap:10px; align-items:center; }

    .hint{ font-size:11px; color:rgba(231,236,255,.65); }

    /* SAFETY: FORCE DESKTOP SIDE-BY-SIDE */
    @media (min-width: 1100px){
      .wrap{ max-width:1400px; }
      .grid{ grid-template-columns:1fr 1fr !important; align-items:start !important; }
    }
  </style>
</head>

<body>
<div class="wrap">
  <div class="topbar">
    <div class="title">
      <h1>KG Battle Calculator (UI v2)</h1>
      <div class="sub">Two-column layout + “Paste Spy Report” auto-fill for Defending Kingdom</div>
    </div>
    <div class="pillrow">
      <label class="pill"><input id="tgUseResearch" type="checkbox" checked> Use Research (+10%)</label>
      <label class="pill"><input id="tgUseWrath" type="checkbox"> Wrath (+5% all attack)</label>
      <label class="pill"><input id="tgUseSteedsFury" type="checkbox"> Steed's Fury (+5% mounted attack)</label>
      <label class="pill"><input id="tgUseCalibration" type="checkbox" checked> Use Known Hit Calibration</label>
      <label class="pill"><input id="tgUseTargetProfiles" type="checkbox" checked> Prefer Target Profiles</label>
      <label class="pill"><input id="tgUseTargetResearch" type="checkbox" checked> Use Target Research</label>
      <label class="pill"><input id="tgCompact" type="checkbox" checked> Compact Rows</label>
      <label class="pill"><input id="tgLockDef" type="checkbox"> Lock Defending (no autofill overwrite)</label>
    </div>
  </div>

  <div class="grid">
    <!-- LEFT -->
    <section class="card">
      <div class="cardHeader">
        <div class="h">
          <div class="t">Attacking Force</div>
          <div class="d">Your units, boosts, and attack setup</div>
        </div>
        <button class="btn ghost" id="btnClearAtk">Clear</button>
      </div>
      <div class="cardBody">
        <div class="rows" id="atkRows">
          <div class="row compact">
            <div class="lbl">Attack Type</div>
            <select class="inp" id="atkType">
              <option value="attack">Attack</option>
            </select>
          </div>

          <div class="divider"></div>
          <div class="sectionTitle">Units</div>

          <div class="twocol">
            <div class="rows">
              <div class="row compact">
                <div class="lbl">Footmen</div>
                <input class="inp" id="atkFoot" type="number" min="0" step="1" value="0" />
              </div>
              <div class="row compact">
                <div class="lbl">Pikemen</div>
                <input class="inp" id="atkPike" type="number" min="0" step="1" value="0" />
              </div>
              <div class="row compact">
                <div class="lbl">Archers</div>
                <input class="inp" id="atkArc" type="number" min="0" step="1" value="0" />
              </div>

              <div class="divider"></div>

              <div class="row compact">
                <div class="lbl">Light Cavalry</div>
                <input class="inp" id="atkLCav" type="number" min="0" step="1" value="0" />
              </div>
              <div class="row compact">
                <div class="lbl">Heavy Cavalry</div>
                <input class="inp" id="atkHCav" type="number" min="0" step="1" value="0" />
              </div>
              <div class="row compact">
                <div class="lbl">Knights</div>
                <input class="inp" id="atkKnights" type="number" min="0" step="1" value="0" />
              </div>
            </div>

            <div class="rows">
              <div class="row compact">
                <div class="lbl">Spies Sent</div>
                <input class="inp" id="atkSpies" type="number" min="0" step="1" value="0" />
              </div>
              <div class="row compact">
                <div class="lbl">Castles (attacker)</div>
                <input class="inp" id="atkCastles" type="number" min="0" step="1" value="0" />
              </div>

              <div class="divider"></div>

              <div class="hint">
                Footmen/Pikemen split for correct AP. Mounted units split because LC/HC/Knights have different AP values.
              </div>
            </div>
          </div>

          <div class="divider"></div>
          <div class="sectionTitle">Modifiers</div>

          <div class="row compact">
            <div class="lbl">Attack Bonus %</div>
            <input class="inp" id="atkBonus" type="number" min="-99" step="0.1" value="0" />
          </div>
          <div class="row compact">
            <div class="lbl">Morale / Situational %</div>
            <input class="inp" id="atkMorale" type="number" min="-99" step="0.1" value="0" />
          </div>

          <div class="btnrow">
            <button class="btn" id="btnCalc">Calculate</button>
            <button class="btn ghost" id="btnCopyAtk">Copy Attack JSON</button>
          </div>

          <div class="status" id="atkStatus"></div>

          <div class="divider"></div>
          <div class="sectionTitle">Known Hit Calibration</div>
          <div class="twocol">
            <div class="rows">
              <div class="row compact">
                <div class="lbl">Observed Outcome</div>
                <select class="inp" id="khOutcome">
                  <option value="">Select outcome...</option>
                  <option value="FAIL / LOSS">Fail / Loss</option>
                  <option value="STALEMATE">Stalemate</option>
                  <option value="MINOR VICTORY">Minor Victory</option>
                  <option value="VICTORY">Victory</option>
                  <option value="MAJOR VICTORY">Major Victory</option>
                  <option value="OVERWHELMING VICTORY">Overwhelming Victory</option>
                </select>
              </div>
              <div class="row compact">
                <div class="lbl">Land Taken (optional)</div>
                <input class="inp" id="khLandTaken" type="number" min="0" step="1" />
              </div>
            </div>
            <div class="rows">
              <div class="row compact">
                <div class="lbl">Hit Note (optional)</div>
                <input class="inp" id="khNote" />
              </div>
              <div class="hint">Run Calculate first, then save the actual hit result. Calibration updates automatically.</div>
            </div>
          </div>
          <div class="btnrow">
            <button class="btn" id="btnAddKnownHit">Save Known Hit</button>
            <button class="btn ghost" id="btnClearKnownHits">Clear Known Hits</button>
            <button class="btn ghost" id="btnExportKnownHitsCsv">Export CSV</button>
            <button class="btn ghost" id="btnImportKnownHitsCsv">Import CSV</button>
            <input id="knownHitsCsvFile" type="file" accept=".csv,text/csv" style="display:none;" />
          </div>
          <div class="status" id="calStatus"></div>
          <div class="btnrow">
            <label class="pill"><input id="khShowCurrentOnly" type="checkbox"> Show current target only</label>
          </div>
          <div style="overflow:auto; border:1px solid var(--border); border-radius:10px; margin-top:8px;">
            <table style="width:100%; border-collapse:collapse; font-size:12px;">
              <thead>
                <tr>
                  <th style="text-align:left; padding:8px; border-bottom:1px solid var(--border); color:var(--muted);">Date</th>
                  <th style="text-align:left; padding:8px; border-bottom:1px solid var(--border); color:var(--muted);">Target</th>
                  <th style="text-align:left; padding:8px; border-bottom:1px solid var(--border); color:var(--muted);">Raw Ratio</th>
                  <th style="text-align:left; padding:8px; border-bottom:1px solid var(--border); color:var(--muted);">Pred</th>
                  <th style="text-align:left; padding:8px; border-bottom:1px solid var(--border); color:var(--muted);">Observed</th>
                  <th style="text-align:left; padding:8px; border-bottom:1px solid var(--border); color:var(--muted);">Land</th>
                  <th style="text-align:left; padding:8px; border-bottom:1px solid var(--border); color:var(--muted);">Note</th>
                  <th style="text-align:left; padding:8px; border-bottom:1px solid var(--border); color:var(--muted);">Actions</th>
                </tr>
              </thead>
              <tbody id="knownHitsBody"></tbody>
            </table>
          </div>
        </div>
      </div>
    </section>

    <!-- RIGHT -->
    <section class="card">
      <div class="cardHeader">
        <div class="h">
          <div class="t">Defending Kingdom</div>
          <div class="d">Paste Spy Report to auto-fill target + troops + resources</div>
        </div>
        <button class="btn ghost" id="btnClearDef">Clear</button>
      </div>
      <div class="cardBody">
        <div class="rows" id="defRows">
          <div class="row compact">
            <div class="lbl">Paste Spy Report</div>
            <button class="btn" id="btnParse">Parse & Auto-fill</button>
          </div>

          <textarea class="ta" id="spyPaste" placeholder="Paste the full Spy Report here..."></textarea>

          <div class="hint">
            Parses: Target, Alliance, Honour, Ranking, Networth, Spies Sent/Lost, Result Level, # Castles,
            Resources, and troops (ignores Population + Approx defensive power lines).
          </div>

          <div class="divider"></div>
          <div class="sectionTitle">Defender Summary</div>

          <div class="twocol">
            <div class="rows">
              <div class="row compact">
                <div class="lbl">Target</div>
                <input class="inp" id="defTarget" />
              </div>
              <div class="row compact">
                <div class="lbl">Alliance</div>
                <input class="inp" id="defAlliance" />
              </div>
              <div class="row compact">
                <div class="lbl">Ranking</div>
                <input class="inp" id="defRank" type="number" min="0" step="1" />
              </div>
            </div>
            <div class="rows">
              <div class="row compact">
                <div class="lbl">Networth</div>
                <input class="inp" id="defNetworth" type="number" min="0" step="1" />
              </div>
              <div class="row compact">
                <div class="lbl">Honour</div>
                <input class="inp" id="defHonour" type="number" step="0.01" />
              </div>
              <div class="row compact">
                <div class="lbl">Castles</div>
                <input class="inp" id="defCastles" type="number" min="0" step="1" />
              </div>
              <div class="row compact">
                <div class="lbl">Defender DP (override)</div>
                <input class="inp" id="defDP" type="number" min="0" step="1" />
              </div>
            </div>
          </div>

          <div class="divider"></div>
          <div class="sectionTitle">Defender Troops</div>

          <div class="troopList" id="troopList"></div>

          <div class="btnrow">
            <button class="btn ghost" id="btnAddTroop">+ Add Troop Row</button>
            <button class="btn ghost" id="btnCopyDef">Copy Defender JSON</button>
          </div>

          <div class="divider"></div>
          <div class="sectionTitle">Resources (optional)</div>

          <div class="twocol">
            <div class="rows">
              <div class="row compact"><div class="lbl">Gold</div><input class="inp" id="resGold" type="number" min="0" step="1" /></div>
              <div class="row compact"><div class="lbl">Food</div><input class="inp" id="resFood" type="number" min="0" step="1" /></div>
              <div class="row compact"><div class="lbl">Wood</div><input class="inp" id="resWood" type="number" min="0" step="1" /></div>
            </div>
            <div class="rows">
              <div class="row compact"><div class="lbl">Stone</div><input class="inp" id="resStone" type="number" min="0" step="1" /></div>
              <div class="row compact"><div class="lbl">Horses</div><input class="inp" id="resHorses" type="number" min="0" step="1" /></div>
              <div class="row compact"><div class="lbl">Gems (blue/green)</div><input class="inp" id="resGems" placeholder="e.g. 97 / 90" /></div>
            </div>
          </div>

          <div class="status" id="defStatus"></div>
        </div>
      </div>
    </section>
  </div>
</div>

<script>
  console.log("KG CALC LOADED v2", new Date().toISOString());

  // ---------- DOM HELPERS ----------
  const el = (id) => document.getElementById(id);

  function setStatus(node, items) {
    if (!node) return;
    node.innerHTML = "";
    for (const it of items) {
      const d = document.createElement("div");
      d.className = "kv";
      d.innerHTML = `<b>${it.k}:</b> ${it.v}`;
      node.appendChild(d);
    }
  }

  function clearTroopRows(){ el("troopList").innerHTML = ""; }

  function addTroopRow(name = "", count = 0) {
    const wrap = el("troopList");
    const row = document.createElement("div");
    row.className = "troopItem";

    const nameInp = document.createElement("input");
    nameInp.className = "inp";
    nameInp.placeholder = "Troop name (e.g., Heavy Cavalry)";
    nameInp.value = name;

    const countInp = document.createElement("input");
    countInp.className = "inp";
    countInp.type = "number";
    countInp.min = "0";
    countInp.step = "1";
    countInp.value = (count ?? 0);

    row.appendChild(nameInp);
    row.appendChild(countInp);
    wrap.appendChild(row);
  }

  function readTroopsFromRows(){
    const troops = {};
    const rows = Array.from(el("troopList").querySelectorAll(".troopItem"));
    for (const r of rows) {
      const [nameInp, countInp] = r.querySelectorAll("input");
      const name = (nameInp.value || "").trim();
      const count = Number(String(countInp.value || "0").replace(/[, ]+/g, ""));
      if (!name) continue;
      if (!Number.isFinite(count)) continue;
      troops[name] = count;
    }
    return troops;
  }

  // ---------- PARSER ----------
  function parseNumberLoose(s){
    if (s == null) return null;
    const cleaned = String(s).replace(/[, ]+/g, "").trim();
    if (!cleaned) return null;
    const n = Number(cleaned);
    return Number.isFinite(n) ? n : null;
  }

  function grabLineValue(text, label){
    const re = new RegExp("^\\s*" + label.replace(/[.*+?^${}()|[\\]\\\\]/g, "\\$&") + "\\s*:\\s*(.+?)\\s*$", "im");
    const m = text.match(re);
    return m ? m[1].trim() : null;
  }

  function sliceSection(text, headerRegex, stopRegexes){
    const m = text.match(headerRegex);
    if (!m) return "";
    const startIdx = (m.index ?? 0) + m[0].length;
    const after = text.slice(startIdx);

    let endIdx = after.length;
    for (const re of stopRegexes) {
      const sm = after.match(re);
      if (sm && typeof sm.index === "number") endIdx = Math.min(endIdx, sm.index);
    }
    return after.slice(0, endIdx).trim();
  }

  function parseKeyValueLines(chunk){
    const out = {};
    const lines = chunk.split(/\r?\n/);
    for (const line of lines) {
      if (/^\s*\*/.test(line)) continue;
      const m = line.match(/^\s*([^:]{1,80}?)\s*:\s*([0-9][0-9, ]*)\s*$/);
      if (!m) continue;
      const key = m[1].trim();
      const val = parseNumberLoose(m[2]);
      if (val == null) continue;
      out[key] = val;
    }
    return out;
  }

  function extractResources(text){
    const resourcesChunk = sliceSection(
      text,
      /^\s*Our spies also found the following information about the kingdom's resources:\s*$/im,
      [
        /^\s*Our spies also found the following information about the kingdom's troops:\s*$/im,
        /^\s*The following information was found regarding troop movements/i,
        /^\s*Select Ruleset:/im,
        /^\s*Standard Rules/im
      ]
    );

    const kv = parseKeyValueLines(resourcesChunk);
    const res = {};
    if (kv["Gold"] != null) res.gold = kv["Gold"];
    if (kv["Food"] != null) res.food = kv["Food"];
    if (kv["Wood"] != null) res.wood = kv["Wood"];
    if (kv["Stone"] != null) res.stone = kv["Stone"];
    if (kv["Horses"] != null) res.horses = kv["Horses"];
    if (kv["Blue Gems"] != null) res.blueGems = kv["Blue Gems"];
    if (kv["Green Gems"] != null) res.greenGems = kv["Green Gems"];

    const landRaw = grabLineValue(resourcesChunk, "Land");
    if (landRaw) res.landRaw = landRaw;

    return res;
  }

  function extractTroops(text){
    const troopsChunk = sliceSection(
      text,
      /^\s*Our spies also found the following information about the kingdom's troops:\s*$/im,
      [
        /^\s*The following information was found regarding troop movements/i,
        /^\s*Select Ruleset:/im,
        /^\s*Standard Rules/im
      ]
    );

    const kv = parseKeyValueLines(troopsChunk);

    const troops = {};
    for (const [k, v] of Object.entries(kv)) {
      const lk = k.toLowerCase();
      if (lk.startsWith("population")) continue;
      if (lk.includes("defensive power")) continue;
      troops[k] = v;
    }
    return troops;
  }

  function parseKgSpyReport(text){
    return {
      target: grabLineValue(text, "Target"),
      alliance: grabLineValue(text, "Alliance"),
      honour: parseNumberLoose(grabLineValue(text, "Honour")),
      ranking: parseNumberLoose(grabLineValue(text, "Ranking")),
      networth: parseNumberLoose(grabLineValue(text, "Networth")),
      spiesSent: parseNumberLoose(grabLineValue(text, "Spies Sent")),
      spiesLost: parseNumberLoose(grabLineValue(text, "Spies Lost")),
      resultLevel: grabLineValue(text, "Result Level"),
      castles: parseNumberLoose(grabLineValue(text, "Number of Castles")),
      resources: extractResources(text),
      troops: extractTroops(text),
    };
  }

  function extractDefenderDPFromSpyText(text){
    const m = String(text || "").match(/Approximate defensive power\*?\s*:\s*([0-9,]+)/i);
    if (!m) return null;
    return Number(m[1].replace(/,/g, ""));
  }

  // ---------- BATTLE MATH ----------
  // Troop stats from KG guide + configurable RPS settings.
  const ATTACK_WEIGHTS = {
    footmen: 1,
    pikemen: 2,
    elites: 10,
    archers: 1,
    crossbowmen: 3,
    lightCav: 5,
    heavyCav: 7,
    knights: 15
  };

  const DEFENSE_WEIGHTS = {
    peasants: 0.1,
    footmen: 1,
    pikemen: 2,
    elites: 10,
    archers: 4,
    crossbowmen: 2,
    lightCav: 4,
    heavyCav: 5,
    knights: 10
  };

  const RPS_CONFIG = {
    pikeVsCavNeedRatio: 0.25,     // 25% pike can fully counter cav
    cavVsArchNeedRatio: 1.0,      // 1:1
    archVsInfNeedRatio: 1.0,      // 1:1
    fullCounterReduction: 0.25,   // 25% reduction at full coverage
    maxCounterReduction: 0.25     // hard cap for over-coverage
  };

  const TARGET_RESEARCH_RULES = [
    { name: "Horse Breeding", affects: "cavalry", rate: 0.005, ap: true, dp: false },
    { name: "War Horse", affects: "cavalry", rate: 0.005, ap: true, dp: false },
    { name: "City Walls", affects: "all", rate: 0.0025, ap: false, dp: true },
    { name: "Curtain Walls", affects: "castles", rate: 0.01, ap: false, dp: true },
    { name: "Improved Castles (Mot and Bailey)", affects: "castles", rate: 0.01, ap: false, dp: true },
    { name: "Improved Defences", affects: "castles", rate: 0.01, ap: false, dp: true },
    { name: "Moats", affects: "castles", rate: 0.01, ap: false, dp: true },
    { name: "Palisades", affects: "all", rate: 0.0025, ap: false, dp: true },
    { name: "Roads", affects: "all", rate: 0.0025, ap: false, dp: false },
    { name: "Good Medical Practice", affects: "all", rate: 0.005, ap: false, dp: false },
    { name: "Herbalism", affects: "all", rate: 0.005, ap: false, dp: false },
    { name: "Hospitals", affects: "all", rate: 0.005, ap: false, dp: false },
    { name: "Medicine", affects: "all", rate: 0.005, ap: false, dp: false },
    { name: "Advanced Weapon Design", affects: "all", rate: 0.0025, ap: true, dp: true },
    { name: "Better Training Methods", affects: "all", rate: 0.0025, ap: true, dp: true },
    { name: "Improved Weapon Design", affects: "all", rate: 0.0025, ap: true, dp: true },
    { name: "Lance Formation", affects: "cavalry", rate: 0.01, ap: false, dp: true },
    { name: "Leadership Training", affects: "all", rate: 0.0025, ap: false, dp: true },
    { name: "Loose Order Formation", affects: "all", rate: 0.01, ap: false, dp: true },
    { name: "Military Encampment", affects: "all", rate: 0.01, ap: true, dp: false },
    { name: "Phlanx", affects: "infantry", rate: 0.01, ap: false, dp: true },
    { name: "Sharpshooter", affects: "archers", rate: 0.01, ap: false, dp: true },
    { name: "Tactics", affects: "all", rate: 0.0025, ap: true, dp: false },
  ];

  const TARGET_RESEARCH_CACHE = new Map();

  const OUTCOME_THRESHOLDS = [
    { name: "FLEE", min: 0.0, max: 0.25, landDown: null, landUp: null },
    { name: "MAJOR LOSS", min: 0.25, max: 0.75, landDown: null, landUp: null },
    { name: "MINOR LOSS", min: 0.75, max: 0.95, landDown: null, landUp: null },
    { name: "STALEMATE", min: 0.95, max: 1.15, landDown: 0.5, landUp: 1.0 },
    { name: "MINOR VICTORY", min: 1.15, max: 1.40, landDown: 1.0, landUp: 2.0 },
    { name: "VICTORY", min: 1.40, max: 2.50, landDown: 1.75, landUp: 3.5 },
    { name: "MAJOR VICTORY", min: 2.50, max: 5.0, landDown: 2.5, landUp: 5.0 },
    { name: "OVERWHELMING VICTORY", min: 5.0, max: Infinity, landDown: 3.5, landUp: 7.0 },
  ];

  const CAL_STORAGE_KEY = "kg_calc_known_hits_v1";
  let lastCalcSnapshot = null;

  function median(nums){
    const v = (nums || []).filter(n => Number.isFinite(n)).slice().sort((a,b) => a - b);
    if (!v.length) return 1;
    const m = Math.floor(v.length / 2);
    return v.length % 2 ? v[m] : (v[m - 1] + v[m]) / 2;
  }

  function normalizeProfileTarget(name){
    return String(name || "").trim().toLowerCase();
  }

  function sanitizeKnownHit(h){
    const rawRatio = Number(h?.rawRatio || 0);
    const actualOutcome = String(h?.actualOutcome || "").trim();
    if (!(rawRatio > 0) || !actualOutcome) return null;
    const target = String(h?.target || "").trim();
    return {
      id: String(h?.id || `${Date.now()}_${Math.random().toString(36).slice(2, 8)}`),
      ts: String(h?.ts || new Date().toISOString()),
      target: target,
      targetNorm: normalizeProfileTarget(target),
      rawRatio: rawRatio,
      calibratedRatio: Number(h?.calibratedRatio || 0),
      predictedOutcome: String(h?.predictedOutcome || ""),
      actualOutcome: actualOutcome,
      atkPower: Number(h?.atkPower || 0),
      defDP: Number(h?.defDP || 0),
      landTaken: h?.landTaken == null ? null : Number(h.landTaken),
      note: h?.note == null ? null : String(h.note)
    };
  }

  function loadKnownHits(){
    try {
      const raw = localStorage.getItem(CAL_STORAGE_KEY);
      if (!raw) return [];
      const parsed = JSON.parse(raw);
      if (!Array.isArray(parsed)) return [];
      return parsed.map(sanitizeKnownHit).filter(Boolean);
    } catch {
      return [];
    }
  }

  function saveKnownHits(hits){
    localStorage.setItem(CAL_STORAGE_KEY, JSON.stringify(hits || []));
  }

  function outcomeTargetRatio(name){
    const n = String(name || "").toUpperCase().trim();
    if (n === "FAIL / LOSS") return 0.85;
    if (n === "STALEMATE") return 1.02;
    if (n === "MINOR VICTORY") return 1.20;
    if (n === "VICTORY") return 1.45;
    if (n === "MAJOR VICTORY") return 1.90;
    if (n === "OVERWHELMING VICTORY") return 2.40;
    return null;
  }

  function extractFactors(knownHits){
    const ratios = [];
    for (const h of (knownHits || [])) {
      const rawRatio = Number(h.rawRatio || 0);
      const target = outcomeTargetRatio(h.actualOutcome);
      if (!(rawRatio > 0) || !(target > 0)) continue;
      const factor = target / rawRatio;
      if (Number.isFinite(factor)) ratios.push(Math.max(0.60, Math.min(1.80, factor)));
    }
    return ratios;
  }

  function computeConfidencePct(sampleCount, factorMad){
    const n = Number(sampleCount || 0);
    const mad = Number(factorMad || 0);
    const sampleScore = Math.min(1, n / 12);
    const stabilityScore = Math.max(0, Math.min(1, 1 - (mad / 0.18)));
    return Math.round((0.70 * sampleScore + 0.30 * stabilityScore) * 100);
  }

  function computeCalibrationStats(knownHits, currentTarget, useTargetProfiles){
    const all = knownHits || [];
    const targetNorm = normalizeProfileTarget(currentTarget);
    const targetHits = targetNorm ? all.filter(h => h.targetNorm === targetNorm) : [];

    let active = all;
    let profile = "global";
    if (useTargetProfiles && targetHits.length >= 3) {
      active = targetHits;
      profile = `target:${targetNorm || "unknown"}`;
    }

    const factors = extractFactors(active);
    const factor = factors.length ? median(factors) : 1;
    const absDevs = factors.map(v => Math.abs(v - factor));
    const factorMad = absDevs.length ? median(absDevs) : 0;
    const confidencePct = computeConfidencePct(factors.length, factorMad);

    return {
      factor,
      confidencePct,
      factorMad,
      profile,
      activeSamples: factors.length,
      totalHits: all.length,
      targetHits: targetHits.length,
      targetNorm
    };
  }

  function getKnownHits(){
    return loadKnownHits();
  }

  function knownOutcomeOptions(selected){
    const vals = ["FAIL / LOSS", "STALEMATE", "MINOR VICTORY", "VICTORY", "MAJOR VICTORY", "OVERWHELMING VICTORY"];
    return vals.map(v => `<option value="${v}" ${v === selected ? "selected" : ""}>${v}</option>`).join("");
  }

  function escapeHtml(v){
    return String(v ?? "")
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#39;");
  }

  function csvEscape(val){
    const s = String(val ?? "");
    if (/[",\r\n]/.test(s)) return `"${s.replaceAll('"', '""')}"`;
    return s;
  }

  function knownHitsToCsv(hits){
    const headers = ["id", "ts", "target", "rawRatio", "calibratedRatio", "predictedOutcome", "actualOutcome", "atkPower", "defDP", "landTaken", "note"];
    const rows = [headers.join(",")];
    for (const h of (hits || [])) {
      const row = headers.map(k => csvEscape(h?.[k] ?? ""));
      rows.push(row.join(","));
    }
    return rows.join("\n");
  }

  function parseCsvLine(line){
    const out = [];
    let cur = "";
    let i = 0;
    let inQ = false;
    while (i < line.length) {
      const ch = line[i];
      if (inQ) {
        if (ch === '"') {
          if (line[i + 1] === '"') {
            cur += '"';
            i += 2;
            continue;
          }
          inQ = false;
          i += 1;
          continue;
        }
        cur += ch;
        i += 1;
        continue;
      }
      if (ch === ",") {
        out.push(cur);
        cur = "";
        i += 1;
        continue;
      }
      if (ch === '"') {
        inQ = true;
        i += 1;
        continue;
      }
      cur += ch;
      i += 1;
    }
    out.push(cur);
    return out;
  }

  function knownHitsFromCsv(csvText){
    const txt = String(csvText || "").replace(/\r/g, "");
    const lines = txt.split("\n").filter(l => l.trim().length > 0);
    if (lines.length < 2) return [];
    const headers = parseCsvLine(lines[0]).map(h => String(h || "").trim());
    const idx = Object.fromEntries(headers.map((h, i) => [h, i]));
    const required = ["rawRatio", "actualOutcome"];
    for (const r of required) {
      if (!(r in idx)) throw new Error(`CSV missing required column: ${r}`);
    }

    const out = [];
    for (let li = 1; li < lines.length; li++) {
      const cols = parseCsvLine(lines[li]);
      const get = (k) => (idx[k] == null ? "" : String(cols[idx[k]] ?? "").trim());
      const row = sanitizeKnownHit({
        id: get("id"),
        ts: get("ts"),
        target: get("target"),
        rawRatio: Number(get("rawRatio")),
        calibratedRatio: Number(get("calibratedRatio")),
        predictedOutcome: get("predictedOutcome"),
        actualOutcome: get("actualOutcome"),
        atkPower: Number(get("atkPower")),
        defDP: Number(get("defDP")),
        landTaken: get("landTaken") === "" ? null : Number(get("landTaken")),
        note: get("note")
      });
      if (row) out.push(row);
    }
    return out;
  }

  function renderKnownHitsTable(){
    const body = el("knownHitsBody");
    if (!body) return;

    const all = getKnownHits();
    const showCurrentOnly = !!el("khShowCurrentOnly")?.checked;
    const currentTarget = normalizeProfileTarget(el("defTarget")?.value || "");
    let items = all.slice().sort((a, b) => String(b.ts).localeCompare(String(a.ts)));
    if (showCurrentOnly && currentTarget) {
      items = items.filter(h => h.targetNorm === currentTarget);
    }

    if (!items.length) {
      body.innerHTML = `<tr><td colspan="8" style="padding:10px; color:var(--muted);">No known hits saved yet.</td></tr>`;
      return;
    }

    body.innerHTML = items.map(h => `
      <tr data-hit-id="${escapeHtml(h.id)}">
        <td style="padding:8px; border-top:1px solid var(--border); white-space:nowrap;">${escapeHtml(String(h.ts).replace("T"," ").slice(0,19))}</td>
        <td style="padding:8px; border-top:1px solid var(--border); min-width:120px;"><input class="inp" data-f="target" value="${escapeHtml(h.target || "")}" /></td>
        <td style="padding:8px; border-top:1px solid var(--border); white-space:nowrap;">${Number(h.rawRatio || 0).toFixed(2)}</td>
        <td style="padding:8px; border-top:1px solid var(--border); white-space:nowrap;">${escapeHtml(h.predictedOutcome || "—")}</td>
        <td style="padding:8px; border-top:1px solid var(--border); min-width:170px;"><select class="inp" data-f="actualOutcome">${knownOutcomeOptions(h.actualOutcome)}</select></td>
        <td style="padding:8px; border-top:1px solid var(--border); width:100px;"><input class="inp" data-f="landTaken" type="number" min="0" step="1" value="${h.landTaken == null ? "" : escapeHtml(h.landTaken)}" /></td>
        <td style="padding:8px; border-top:1px solid var(--border); min-width:180px;"><input class="inp" data-f="note" value="${escapeHtml(h.note || "")}" /></td>
        <td style="padding:8px; border-top:1px solid var(--border); white-space:nowrap;">
          <button class="btn ghost" data-act="save">Save</button>
          <button class="btn ghost" data-act="delete">Delete</button>
        </td>
      </tr>
    `).join("");
  }

  function renderCalibrationStatus(){
    const hits = getKnownHits();
    const stats = computeCalibrationStats(hits, el("defTarget")?.value || "", !!el("tgUseTargetProfiles")?.checked);
    setStatus(el("calStatus"), [
      { k:"Known Hits", v: stats.totalHits.toString() },
      { k:"Target Hits", v: stats.targetHits.toString() },
      { k:"Profile", v: stats.profile },
      { k:"Calibration Factor", v: stats.factor.toFixed(3) + "x" },
      { k:"Model Confidence", v: `${stats.confidencePct}%` }
    ]);
    renderKnownHitsTable();
  }

  function normalizeResearchName(name){
    return String(name || "")
      .toLowerCase()
      .replace(/[\(\)\[\]\{\}\.,:'"`]/g, " ")
      .replace(/\s+/g, " ")
      .trim();
  }

  function computeTargetResearchBonuses(levels){
    const bonuses = {
      allPct: 0,
      infantryPct: 0,
      archersPct: 0,
      cavalryPct: 0,
      castlesPct: 0,
      matched: []
    };
    const rules = TARGET_RESEARCH_RULES.map(r => ({ ...r, norm: normalizeResearchName(r.name) }));

    for (const [rawName, rawLvl] of Object.entries(levels || {})) {
      const lvl = Number(rawLvl || 0);
      if (!(lvl > 0)) continue;
      const n = normalizeResearchName(rawName);
      const rule = rules.find(r => n === r.norm || n.includes(r.norm) || r.norm.includes(n));
      if (!rule) continue;

      const pct = rule.rate * lvl;
      bonuses.matched.push({ name: rule.name, level: lvl, pct, dp: rule.dp, ap: rule.ap, affects: rule.affects });

      if (!rule.dp) continue;
      if (rule.affects === "all") bonuses.allPct += pct;
      else if (rule.affects === "infantry") bonuses.infantryPct += pct;
      else if (rule.affects === "archers") bonuses.archersPct += pct;
      else if (rule.affects === "cavalry") bonuses.cavalryPct += pct;
      else if (rule.affects === "castles") bonuses.castlesPct += pct;
    }
    return bonuses;
  }

  async function fetchTargetResearchProfile(target){
    const t = String(target || "").trim();
    const norm = normalizeProfileTarget(t);
    if (!norm) return { target: t, levels: {}, bonuses: computeTargetResearchBonuses({}), reportsScanned: 0 };
    if (TARGET_RESEARCH_CACHE.has(norm)) return TARGET_RESEARCH_CACHE.get(norm);

    const profile = { target: t, levels: {}, bonuses: computeTargetResearchBonuses({}), reportsScanned: 0 };
    try {
      const res = await fetch(`/api/kingdoms/${encodeURIComponent(t)}/spy-reports?limit=30`, { credentials: "include" });
      const data = await res.json().catch(() => ({}));
      if (!res.ok || !Array.isArray(data?.reports)) {
        TARGET_RESEARCH_CACHE.set(norm, profile);
        return profile;
      }

      const merged = {};
      for (const r of data.reports) {
        const rl = r?.parsed?.research_levels || {};
        for (const [k, v] of Object.entries(rl)) {
          const lvl = Number(v || 0);
          if (!(lvl > 0)) continue;
          merged[k] = Math.max(Number(merged[k] || 0), lvl);
        }
      }
      profile.levels = merged;
      profile.bonuses = computeTargetResearchBonuses(merged);
      profile.reportsScanned = data.reports.length;
    } catch {
      // keep empty profile
    }

    TARGET_RESEARCH_CACHE.set(norm, profile);
    return profile;
  }

  function castleBonusFromCount(castles){
    const c = Number(castles || 0);
    if (!Number.isFinite(c) || c <= 0) return 0;
    return Math.sqrt(c) / 100;
  }

  function normalizeTroopName(name){
    const n = String(name || "").toLowerCase().trim();
    if (!n) return null;
    if (n.includes("foot")) return "footmen";
    if (n.includes("pike")) return "pikemen";
    if (n.includes("elite")) return "elites";
    if (n.includes("crossbow")) return "crossbowmen";
    if (n.includes("archer")) return "archers";
    if (n.includes("light") && n.includes("cav")) return "lightCav";
    if (n.includes("heavy") && n.includes("cav")) return "heavyCav";
    if (n.includes("knight")) return "knights";
    if (n.includes("peasant")) return "peasants";
    if (n.includes("cav")) return "lightCav";
    return null;
  }

  function computeCounterReduction(counterCount, targetCount, needRatio){
    const c = Number(counterCount || 0);
    const t = Number(targetCount || 0);
    if (!(c > 0) || !(t > 0) || !(needRatio > 0)) return 0;
    const needed = t * needRatio;
    if (!(needed > 0)) return 0;
    const coverage = c / needed;
    if (!(coverage > 0)) return 0;
    const pct = RPS_CONFIG.fullCounterReduction * coverage;
    return Math.max(0, Math.min(RPS_CONFIG.maxCounterReduction, pct));
  }

  function buildAttackerUnitBreakdown(){
    const foot = parseNumberLoose(el("atkFoot").value) ?? 0;
    const pike = parseNumberLoose(el("atkPike").value) ?? 0;
    const arc = parseNumberLoose(el("atkArc").value) ?? 0;
    const lcav = parseNumberLoose(el("atkLCav").value) ?? 0;
    const hcav = parseNumberLoose(el("atkHCav").value) ?? 0;
    const knights = parseNumberLoose(el("atkKnights").value) ?? 0;
    return { footmen: foot, pikemen: pike, archers: arc, lightCav: lcav, heavyCav: hcav, knights: knights, elites: 0, crossbowmen: 0 };
  }

  function buildDefenderUnitBreakdownFromRows(){
    const troops = readTroopsFromRows();
    const out = {
      peasants: 0,
      footmen: 0,
      pikemen: 0,
      elites: 0,
      archers: 0,
      crossbowmen: 0,
      lightCav: 0,
      heavyCav: 0,
      knights: 0
    };
    for (const [name, rawCount] of Object.entries(troops || {})) {
      const key = normalizeTroopName(name);
      if (!key) continue;
      const count = Number(rawCount || 0);
      if (!Number.isFinite(count) || count < 0) continue;
      out[key] += count;
    }
    return out;
  }

  function groupedCounts(units){
    return {
      infantry: (units.footmen || 0) + (units.pikemen || 0) + (units.elites || 0),
      archers: (units.archers || 0) + (units.crossbowmen || 0),
      cavalry: (units.lightCav || 0) + (units.heavyCav || 0) + (units.knights || 0),
      pike: (units.pikemen || 0)
    };
  }

  function computeAttackPower(attackerUnits, defenderUnits){
    const a = attackerUnits;
    const d = defenderUnits;
    const ag = groupedCounts(a);
    const dg = groupedCounts(d);

    let infantryAP =
      (a.footmen || 0) * ATTACK_WEIGHTS.footmen +
      (a.pikemen || 0) * ATTACK_WEIGHTS.pikemen +
      (a.elites || 0) * ATTACK_WEIGHTS.elites;
    let archerAP =
      (a.archers || 0) * ATTACK_WEIGHTS.archers +
      (a.crossbowmen || 0) * ATTACK_WEIGHTS.crossbowmen;
    let cavAP =
      (a.lightCav || 0) * ATTACK_WEIGHTS.lightCav +
      (a.heavyCav || 0) * ATTACK_WEIGHTS.heavyCav +
      (a.knights || 0) * ATTACK_WEIGHTS.knights;

    // Defender counters attacker.
    const defPikeVsAtkCav = computeCounterReduction(dg.pike, ag.cavalry, RPS_CONFIG.pikeVsCavNeedRatio);
    const defCavVsAtkArch = computeCounterReduction(dg.cavalry, ag.archers, RPS_CONFIG.cavVsArchNeedRatio);
    const defArchVsAtkInf = computeCounterReduction(dg.archers, ag.infantry, RPS_CONFIG.archVsInfNeedRatio);

    cavAP *= (1 - defPikeVsAtkCav);
    archerAP *= (1 - defCavVsAtkArch);
    infantryAP *= (1 - defArchVsAtkInf);

    let power = infantryAP + archerAP + cavAP;

    const bonusPct = parseNumberLoose(el("atkBonus").value) ?? 0;
    const moralePct = parseNumberLoose(el("atkMorale").value) ?? 0;

    power *= (1 + bonusPct / 100);
    power *= (1 + moralePct / 100);

    if (el("tgUseResearch").checked) power *= 1.10;
    if (el("tgUseWrath").checked) power *= 1.05;
    if (el("tgUseSteedsFury").checked) {
      const mountedBaseAP =
        (a.lightCav || 0) * ATTACK_WEIGHTS.lightCav +
        (a.heavyCav || 0) * ATTACK_WEIGHTS.heavyCav +
        (a.knights || 0) * ATTACK_WEIGHTS.knights;
      const mountedRpsAdjusted = mountedBaseAP * (1 - defPikeVsAtkCav);
      power += (mountedRpsAdjusted * 0.05);
    }

    return {
      power: Math.max(0, power),
      rps: {
        defPikeVsAtkCav,
        defCavVsAtkArch,
        defArchVsAtkInf
      }
    };
  }

  function computeDefenderPower(defenderUnits, attackerUnits, baseDpOverride, targetResearchBonuses){
    const d = defenderUnits;
    const a = attackerUnits;
    const ag = groupedCounts(a);
    const dg = groupedCounts(d);
    const rb = targetResearchBonuses || { allPct: 0, infantryPct: 0, archersPct: 0, cavalryPct: 0, castlesPct: 0, matched: [] };

    // Attacker counters defender.
    const atkPikeVsDefCav = computeCounterReduction(ag.pike, dg.cavalry, RPS_CONFIG.pikeVsCavNeedRatio);
    const atkCavVsDefArch = computeCounterReduction(ag.cavalry, dg.archers, RPS_CONFIG.cavVsArchNeedRatio);
    const atkArchVsDefInf = computeCounterReduction(ag.archers, dg.infantry, RPS_CONFIG.archVsInfNeedRatio);

    let infantryDP =
      (d.footmen || 0) * DEFENSE_WEIGHTS.footmen +
      (d.pikemen || 0) * DEFENSE_WEIGHTS.pikemen +
      (d.elites || 0) * DEFENSE_WEIGHTS.elites;
    let archerDP =
      (d.archers || 0) * DEFENSE_WEIGHTS.archers +
      (d.crossbowmen || 0) * DEFENSE_WEIGHTS.crossbowmen;
    let cavDP =
      (d.lightCav || 0) * DEFENSE_WEIGHTS.lightCav +
      (d.heavyCav || 0) * DEFENSE_WEIGHTS.heavyCav +
      (d.knights || 0) * DEFENSE_WEIGHTS.knights;
    let peasantDP = (d.peasants || 0) * DEFENSE_WEIGHTS.peasants;

    infantryDP *= (1 - atkArchVsDefInf);
    archerDP *= (1 - atkCavVsDefArch);
    cavDP *= (1 - atkPikeVsDefCav);

    const troopBasedDpNoResearch = infantryDP + archerDP + cavDP + peasantDP;

    const infantryResearchMult = 1 + rb.allPct + rb.infantryPct;
    const archerResearchMult = 1 + rb.allPct + rb.archersPct;
    const cavResearchMult = 1 + rb.allPct + rb.cavalryPct;
    const peasantResearchMult = 1 + rb.allPct;

    const infantryDpWithResearch = infantryDP * infantryResearchMult;
    const archerDpWithResearch = archerDP * archerResearchMult;
    const cavDpWithResearch = cavDP * cavResearchMult;
    const peasantDpWithResearch = peasantDP * peasantResearchMult;

    const troopBasedDp = infantryDpWithResearch + archerDpWithResearch + cavDpWithResearch + peasantDpWithResearch;
    const troopResearchMult = troopBasedDpNoResearch > 0 ? (troopBasedDp / troopBasedDpNoResearch) : (1 + rb.allPct);

    const baseDP = (Number(baseDpOverride || 0) > 0)
      ? (Number(baseDpOverride) * troopResearchMult)
      : troopBasedDp;

    const castles = parseNumberLoose(el("defCastles").value) ?? 0;
    const castleBaseBonusPct = castleBonusFromCount(castles);
    const castlesMult = 1 + (castleBaseBonusPct * (1 + rb.castlesPct));

    return {
      baseDP: Math.max(0, baseDP),
      adjustedDP: Math.max(0, baseDP * castlesMult),
      troopBasedDp: Math.max(0, troopBasedDp),
      troopBasedDpNoResearch: Math.max(0, troopBasedDpNoResearch),
      troopResearchMult: Math.max(0, troopResearchMult),
      castlesMult,
      castleBaseBonusPct: Math.max(0, castleBaseBonusPct),
      castleResearchPct: Math.max(0, rb.castlesPct || 0),
      targetResearchBonuses: rb,
      rps: {
        atkPikeVsDefCav,
        atkCavVsDefArch,
        atkArchVsDefInf
      }
    };
  }

  function pickOutcome(ratio){
    for (const t of OUTCOME_THRESHOLDS) {
      if (ratio >= t.min && ratio < t.max) return t;
    }
    return { name: "UNKNOWN", min: 0, max: Infinity, landDown: null, landUp: null };
  }

  function computeOutcomeConfidencePct(ratio, modelConfidencePct){
    const r = Number(ratio || 0);
    const model = Math.max(0, Math.min(100, Number(modelConfidencePct || 0)));
    const boundaries = OUTCOME_THRESHOLDS
      .map(t => Number(t.min))
      .filter(v => Number.isFinite(v) && v > 0);
    let minDist = Infinity;
    for (const b of boundaries) {
      minDist = Math.min(minDist, Math.abs(r - b));
    }
    const marginScore = Math.max(0, Math.min(100, (minDist / 0.20) * 100));
    return Math.round((0.65 * model) + (0.35 * marginScore));
  }

  // ---------- WIRING ----------
  function applyCompact(){
    const compact = el("tgCompact").checked;
    document.querySelectorAll(".row").forEach(r => {
      if (compact) r.classList.add("compact");
      else r.classList.remove("compact");
    });
  }
  el("tgCompact").addEventListener("change", applyCompact);
  applyCompact();

  // seed troop rows
  addTroopRow("", 0);
  addTroopRow("", 0);

  el("btnAddTroop").addEventListener("click", () => addTroopRow("", 0));

  el("btnClearDef").addEventListener("click", () => {
    ["defTarget","defAlliance","defRank","defNetworth","defHonour","defCastles","defDP",
     "resGold","resFood","resWood","resStone","resHorses","resGems"].forEach(id => el(id).value = "");
    clearTroopRows();
    addTroopRow("", 0);
    addTroopRow("", 0);
    setStatus(el("defStatus"), [{ k:"Defender", v:"cleared" }]);
  });

  el("btnClearAtk").addEventListener("click", () => {
    ["atkFoot","atkPike","atkArc","atkLCav","atkHCav","atkKnights","atkSpies","atkCastles","atkBonus","atkMorale"]
      .forEach(id => el(id).value = 0);
    setStatus(el("atkStatus"), [{ k:"Attack", v:"cleared" }]);
  });

  el("btnParse").addEventListener("click", () => {
    const txt = el("spyPaste").value || "";
    if (!txt.trim()) {
      setStatus(el("defStatus"), [{ k:"Parse", v:"no text pasted" }]);
      return;
    }

    const parsed = parseKgSpyReport(txt);
    const lock = el("tgLockDef").checked;

    if (!lock) {
      if (parsed.target != null) el("defTarget").value = parsed.target;
      if (parsed.alliance != null) el("defAlliance").value = parsed.alliance;
      if (parsed.ranking != null) el("defRank").value = parsed.ranking;
      if (parsed.networth != null) el("defNetworth").value = parsed.networth;
      if (parsed.honour != null) el("defHonour").value = parsed.honour;
      if (parsed.castles != null) el("defCastles").value = parsed.castles;
      const parsedDP = extractDefenderDPFromSpyText(txt);
      if (parsedDP != null) el("defDP").value = parsedDP;

      if (parsed.resources.gold != null) el("resGold").value = parsed.resources.gold;
      if (parsed.resources.food != null) el("resFood").value = parsed.resources.food;
      if (parsed.resources.wood != null) el("resWood").value = parsed.resources.wood;
      if (parsed.resources.stone != null) el("resStone").value = parsed.resources.stone;
      if (parsed.resources.horses != null) el("resHorses").value = parsed.resources.horses;

      const blue = parsed.resources.blueGems;
      const green = parsed.resources.greenGems;
      if (blue != null || green != null) el("resGems").value = `${blue ?? ""} / ${green ?? ""}`.trim();

      clearTroopRows();
      const troopEntries = Object.entries(parsed.troops || {});
      if (troopEntries.length) {
        for (const [name, count] of troopEntries) addTroopRow(name, count);
      } else {
        addTroopRow("", 0);
        addTroopRow("", 0);
      }
    }

    const dp = extractDefenderDPFromSpyText(txt);

    setStatus(el("defStatus"), [
      { k:"Target", v: parsed.target ?? "—" },
      { k:"Castles", v: parsed.castles ?? "—" },
      { k:"Defender DP", v: dp != null ? dp.toLocaleString() : "—" },
      { k:"Troop lines", v: Object.keys(parsed.troops || {}).length || "0" },
      { k:"Autofill", v: lock ? "LOCKED" : "applied" }
    ]);
  });

  el("btnCopyDef").addEventListener("click", async () => {
    const data = {
      target: el("defTarget").value.trim(),
      alliance: el("defAlliance").value.trim(),
      ranking: parseNumberLoose(el("defRank").value),
      networth: parseNumberLoose(el("defNetworth").value),
      honour: parseNumberLoose(el("defHonour").value),
      castles: parseNumberLoose(el("defCastles").value),
      defenderDP: parseNumberLoose(el("defDP").value),
      troops: readTroopsFromRows(),
      resources: {
        gold: parseNumberLoose(el("resGold").value),
        food: parseNumberLoose(el("resFood").value),
        wood: parseNumberLoose(el("resWood").value),
        stone: parseNumberLoose(el("resStone").value),
        horses: parseNumberLoose(el("resHorses").value),
        gems: el("resGems").value.trim(),
      }
    };
    await navigator.clipboard.writeText(JSON.stringify(data, null, 2));
    setStatus(el("defStatus"), [{ k:"Copied", v:"defender JSON to clipboard" }]);
  });

  el("btnCopyAtk").addEventListener("click", async () => {
    const data = {
      type: el("atkType").value,
      units: {
        footmen: parseNumberLoose(el("atkFoot").value) ?? 0,
        pikemen: parseNumberLoose(el("atkPike").value) ?? 0,
        archers: parseNumberLoose(el("atkArc").value) ?? 0,
        lightCavalry: parseNumberLoose(el("atkLCav").value) ?? 0,
        heavyCavalry: parseNumberLoose(el("atkHCav").value) ?? 0,
        knights: parseNumberLoose(el("atkKnights").value) ?? 0,
        spiesSent: parseNumberLoose(el("atkSpies").value) ?? 0,
        castles: parseNumberLoose(el("atkCastles").value) ?? 0
      },
      mods: {
        atkBonusPct: parseNumberLoose(el("atkBonus").value) ?? 0,
        moralePct: parseNumberLoose(el("atkMorale").value) ?? 0
      },
      toggles: {
        useResearch: el("tgUseResearch").checked,
        useWrath: el("tgUseWrath").checked,
        useSteedsFury: el("tgUseSteedsFury").checked,
        useCalibration: el("tgUseCalibration").checked,
        useTargetProfiles: el("tgUseTargetProfiles").checked,
        useTargetResearch: el("tgUseTargetResearch").checked
      }
    };
    await navigator.clipboard.writeText(JSON.stringify(data, null, 2));
    setStatus(el("atkStatus"), [{ k:"Copied", v:"attack JSON to clipboard" }]);
  });

  el("btnAddKnownHit").addEventListener("click", () => {
    if (!lastCalcSnapshot) {
      setStatus(el("calStatus"), [{ k:"Save Known Hit", v:"Run Calculate first." }]);
      return;
    }
    const actualOutcome = String(el("khOutcome").value || "").trim();
    if (!actualOutcome) {
      setStatus(el("calStatus"), [{ k:"Save Known Hit", v:"Select Observed Outcome first." }]);
      return;
    }

    const landTaken = parseNumberLoose(el("khLandTaken").value);
    const note = String(el("khNote").value || "").trim();
    const target = String(el("defTarget")?.value || "").trim();
    const hits = getKnownHits();
    hits.push({
      id: `${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,
      ts: new Date().toISOString(),
      target: target,
      targetNorm: normalizeProfileTarget(target),
      rawRatio: Number(lastCalcSnapshot.rawRatio || 0),
      calibratedRatio: Number(lastCalcSnapshot.calibratedRatio || 0),
      predictedOutcome: String(lastCalcSnapshot.predictedOutcome || ""),
      actualOutcome: actualOutcome,
      atkPower: Number(lastCalcSnapshot.atkPower || 0),
      defDP: Number(lastCalcSnapshot.defDP || 0),
      landTaken: landTaken ?? null,
      note: note || null
    });
    saveKnownHits(hits);
    renderCalibrationStatus();
    setStatus(el("atkStatus"), [
      { k:"Known Hit", v:"saved" },
      { k:"Predicted", v:lastCalcSnapshot.predictedOutcome || "—" },
      { k:"Observed", v:actualOutcome },
      { k:"Raw Ratio", v:Number(lastCalcSnapshot.rawRatio || 0).toFixed(2) }
    ]);
  });

  el("knownHitsBody").addEventListener("click", (ev) => {
    const btn = ev.target.closest("button[data-act]");
    if (!btn) return;
    const tr = ev.target.closest("tr[data-hit-id]");
    if (!tr) return;
    const id = String(tr.getAttribute("data-hit-id") || "");
    if (!id) return;

    const hits = getKnownHits();
    const idx = hits.findIndex(h => String(h.id) === id);
    if (idx < 0) return;

    const act = btn.getAttribute("data-act");
    if (act === "delete") {
      hits.splice(idx, 1);
      saveKnownHits(hits);
      renderCalibrationStatus();
      return;
    }

    if (act === "save") {
      const target = String(tr.querySelector("[data-f='target']")?.value || "").trim();
      const actualOutcome = String(tr.querySelector("[data-f='actualOutcome']")?.value || "").trim();
      const landTaken = parseNumberLoose(tr.querySelector("[data-f='landTaken']")?.value);
      const note = String(tr.querySelector("[data-f='note']")?.value || "").trim();
      if (!actualOutcome) {
        setStatus(el("calStatus"), [{ k:"Known Hit", v:"Observed outcome is required." }]);
        return;
      }
      hits[idx] = sanitizeKnownHit({
        ...hits[idx],
        target,
        targetNorm: normalizeProfileTarget(target),
        actualOutcome,
        landTaken: landTaken ?? null,
        note: note || null
      }) || hits[idx];
      saveKnownHits(hits);
      renderCalibrationStatus();
      setStatus(el("calStatus"), [{ k:"Known Hit", v:"row updated" }]);
    }
  });

  el("btnClearKnownHits").addEventListener("click", () => {
    saveKnownHits([]);
    renderCalibrationStatus();
  });

  el("btnExportKnownHitsCsv").addEventListener("click", () => {
    const hits = getKnownHits();
    const csv = knownHitsToCsv(hits);
    const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    const dt = new Date().toISOString().replaceAll(":", "-").slice(0, 19);
    a.href = url;
    a.download = `kg-known-hits-${dt}.csv`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
    setStatus(el("calStatus"), [{ k:"CSV", v:`exported ${hits.length} row(s)` }]);
  });

  el("btnImportKnownHitsCsv").addEventListener("click", () => {
    const f = el("knownHitsCsvFile");
    if (f) f.click();
  });

  el("knownHitsCsvFile").addEventListener("change", async (ev) => {
    const file = ev.target?.files?.[0];
    if (!file) return;
    try {
      const text = await file.text();
      const incoming = knownHitsFromCsv(text);
      const existing = getKnownHits();
      const byId = new Map(existing.map(h => [String(h.id), h]));
      for (const h of incoming) byId.set(String(h.id), h);
      const merged = Array.from(byId.values());
      saveKnownHits(merged);
      renderCalibrationStatus();
      setStatus(el("calStatus"), [{ k:"CSV", v:`imported ${incoming.length} row(s), total ${merged.length}` }]);
    } catch (e) {
      setStatus(el("calStatus"), [{ k:"CSV Import", v:`failed: ${String(e?.message || e)}` }]);
    } finally {
      ev.target.value = "";
    }
  });

  el("tgUseCalibration").addEventListener("change", () => {
    renderCalibrationStatus();
  });
  el("tgUseTargetProfiles").addEventListener("change", () => renderCalibrationStatus());
  el("khShowCurrentOnly").addEventListener("change", () => renderCalibrationStatus());
  el("defTarget").addEventListener("input", () => renderCalibrationStatus());

  el("btnCalc").addEventListener("click", async () => {
    const spyText = el("spyPaste").value || "";
    const manualDP = parseNumberLoose(el("defDP").value);
    const parsedDP = extractDefenderDPFromSpyText(spyText);
    const baseDpOverride = manualDP && manualDP > 0 ? manualDP : parsedDP;
    const targetName = String(el("defTarget")?.value || "").trim();
    const useTargetResearch = !!el("tgUseTargetResearch")?.checked;

    let targetResearchProfile = { target: targetName, levels: {}, bonuses: computeTargetResearchBonuses({}), reportsScanned: 0 };
    if (useTargetResearch && targetName) {
      targetResearchProfile = await fetchTargetResearchProfile(targetName);
    }

    const attackerUnits = buildAttackerUnitBreakdown();
    const defenderUnits = buildDefenderUnitBreakdownFromRows();
    const atk = computeAttackPower(attackerUnits, defenderUnits);
    const def = computeDefenderPower(defenderUnits, attackerUnits, baseDpOverride, targetResearchProfile.bonuses);

    if (!(def.adjustedDP > 0)) {
      setStatus(el("atkStatus"), [
        { k:"Calc", v:"failed" },
        { k:"Reason", v:"Need defender DP from spy/manual input, or defender troop rows to derive DP." }
      ]);
      return;
    }

    const atkPower = atk.power;
    const defDP = def.adjustedDP;
    const rawRatio = atkPower / Math.max(1, defDP);
    const knownHits = getKnownHits();
    const calStats = computeCalibrationStats(
      knownHits,
      el("defTarget")?.value || "",
      !!el("tgUseTargetProfiles")?.checked
    );
    const calFactor = el("tgUseCalibration").checked ? calStats.factor : 1;
    const ratio = rawRatio * calFactor;
    const outcome = pickOutcome(ratio);
    const outcomeConfidencePct = computeOutcomeConfidencePct(ratio, calStats.confidencePct);

    lastCalcSnapshot = {
      ts: new Date().toISOString(),
      rawRatio,
      calibratedRatio: ratio,
      calibrationFactor: calFactor,
      calibrationProfile: calStats.profile,
      calibrationConfidencePct: calStats.confidencePct,
      predictedOutcome: outcome.name,
      atkPower,
      defDP
    };

    const matchedResearch = (targetResearchProfile.bonuses?.matched || []).slice().sort((a, b) => Number(b.pct || 0) - Number(a.pct || 0));
    const topResearch = matchedResearch.slice(0, 3).map(x => `${x.name} L${x.level}`).join(", ");
    const landRange = (outcome.landDown != null && outcome.landUp != null)
      ? `${outcome.landDown.toFixed(2)}%-${outcome.landUp.toFixed(2)}%`
      : "N/A";

    setStatus(el("atkStatus"), [
      { k:"Attack Power", v: Math.round(atkPower).toLocaleString() },
      { k:"Defender DP (base)", v: Math.round(def.baseDP).toLocaleString() },
      { k:"Defender DP (castles)", v: Math.round(defDP).toLocaleString() },
      { k:"Raw Ratio (A/D)", v: rawRatio.toFixed(2) },
      { k:"Calibrated Ratio", v: ratio.toFixed(2) },
      { k:"Predicted Result", v: outcome.name },
      { k:"Land Take Range", v: landRange },
      { k:"Outcome Confidence", v: `${outcomeConfidencePct}%` },
      { k:"DP Source", v: manualDP && manualDP > 0 ? "manual override" : (parsedDP && parsedDP > 0 ? "spy report" : "troop-derived") },
      { k:"Calibration", v: `${calFactor.toFixed(3)}x (${calStats.profile}, ${calStats.activeSamples} sample${calStats.activeSamples === 1 ? "" : "s"})` },
      { k:"Model Confidence", v: `${calStats.confidencePct}%` },
      { k:"Target Research", v: useTargetResearch ? `${matchedResearch.length} matched / ${targetResearchProfile.reportsScanned} report(s)` : "disabled" },
      { k:"Research DP Bonus", v: useTargetResearch ? `${((def.troopResearchMult - 1) * 100).toFixed(2)}% troops, ${(def.castleResearchPct * 100).toFixed(2)}% castles` : "0.00%" },
      { k:"Research Top", v: useTargetResearch ? (topResearch || "None matched") : "disabled" },
      { k:"RPS Def Pike->Atk Cav", v: `${(atk.rps.defPikeVsAtkCav * 100).toFixed(1)}%` },
      { k:"RPS Def Cav->Atk Arch", v: `${(atk.rps.defCavVsAtkArch * 100).toFixed(1)}%` },
      { k:"RPS Def Arch->Atk Inf", v: `${(atk.rps.defArchVsAtkInf * 100).toFixed(1)}%` },
      { k:"RPS Atk Pike->Def Cav", v: `${(def.rps.atkPikeVsDefCav * 100).toFixed(1)}%` },
      { k:"RPS Atk Cav->Def Arch", v: `${(def.rps.atkCavVsDefArch * 100).toFixed(1)}%` },
      { k:"RPS Atk Arch->Def Inf", v: `${(def.rps.atkArchVsDefInf * 100).toFixed(1)}%` },
      { k:"Castle Bonus", v: `${((def.castlesMult - 1) * 100).toFixed(2)}%` }
    ]);
  });

  renderCalibrationStatus();
</script>
</body>
</html>
